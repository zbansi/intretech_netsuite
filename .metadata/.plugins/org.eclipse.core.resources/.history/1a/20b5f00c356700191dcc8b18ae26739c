package com.netsuite.suitetalk.client.common.utils;

import com.netsuite.suitetalk.client.common.EndpointVersion;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.StringWriter;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.netsuite.suitetalk.client.common.Constants.*;

@ParametersAreNonnullByDefault
public final class CommonUtils
{
    private static final Pattern SESSION_ID_PATTERN;
    
    public static String getMessagesUrn(final EndpointVersion endpointVersion) {
        return "urn:messages_" + endpointVersion + ".platform.webservices.netsuite.com";
    }
    
    public static URL composeUrl(final String host, final int port) {
        return composeUrl(getDefaultProtocol(port), host, port);
    }
    
    public static URL composeUrl(final String protocol, final String host, final int port) {
        return composeUrl(protocol, host, port, null);
    }
    
    public static URL composeUrl(final String host, final int port, final String query) {
        return composeUrl(getDefaultProtocol(port), host, port, query);
    }
    
    public static URL composeUrl(final String protocol, final String host, final int port, @Nullable final String query) {
        try {
            return new URL(protocol + "://" + host + ':' + port + ((query == null) ? "" : ("/?" + query)));
        }
        catch (MalformedURLException e) {
            throw new IllegalArgumentException(e);
        }
    }
    
    public static String getDefaultProtocol(final int port) {
        return (port == 443) ? "https" : "http";
    }
    
    public static String parseSessionIdFromCookie(final String cookieValue) {
        final Matcher matcher = CommonUtils.SESSION_ID_PATTERN.matcher(cookieValue);
        if (matcher.matches()) {
            return matcher.replaceAll("$1");
        }
        return null;
    }
    
    public static String getCookieWithoutSessionId(final String cookieValue) {
        return cookieValue.replaceAll("JSESSIONID=" + parseSessionIdFromCookie(cookieValue) + ";?\\s*", "");
    }
    
    public static String formatXml(final String xml, final int indentationSpaces) {
        final String encoding = "UTF-8";
        final String xmlForProcessing = xml.replaceAll(">\\s+<", "><");
        try {
            final Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty("encoding", "UTF-8");
            transformer.setOutputProperty("method", "xml");
            transformer.setOutputProperty("indent", "yes");
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", String.valueOf(indentationSpaces));
            final Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new ByteArrayInputStream(xmlForProcessing.getBytes("UTF-8")));
            final StreamResult result = new StreamResult(new StringWriter());
            transformer.transform(new DOMSource(document), result);
            return result.getWriter().toString();
        }
        catch (ParserConfigurationException | IOException | SAXException | TransformerException ex2) {
            final Exception ex = null;
            final Exception e = ex;
            e.printStackTrace();
            return xml;
        }
    }
    
    public static String formatXml(final String xml) {
        return formatXml(xml, 2);
    }
    
    public static boolean isEmptyString(@Nullable final String string) {
        return string == null || string.isEmpty();
    }
    
    public static String getLogMessage(final String soapMessage, final boolean isRequest) {
        final String mark = "====================";
        final String type = isRequest ? "Request" : "Response";
        final String formattedXml = formatXml(soapMessage);
        return "\n==================== Beginning of " + type + ' ' + "====================" + '\n' + formattedXml + (formattedXml.endsWith("\n") ? "" : '\n') + "====================" + " End of " + type + ' ' + "====================";
    }
    
    public static String concatenateStrings(final String delimiter, final String... strings) {
        if (strings == null || strings.length == 0) {
            return "";
        }
        final StringBuilder sb = new StringBuilder(strings[0]);
        for (int i = 1; i < strings.length; ++i) {
            sb.append(delimiter).append(strings[i]);
        }
        return sb.toString();
    }
    
    public static String bytesToHexString(final byte[] bytes) {
        final char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
        final int length = bytes.length;
        final char[] hexString = new char[length * 2];
        int j = 0;
        for (int i = 0; i < length; ++i) {
            hexString[j++] = digits[(0xF0 & bytes[i]) >>> 4];
            hexString[j++] = digits[0xF & bytes[i]];
        }
        return new String(hexString);
    }
    
    public static String getRandomNonce() {
        return UUID.randomUUID().toString().replace("-", "");
    }
    
    static {
        SESSION_ID_PATTERN = Pattern.compile(".*JSESSIONID=(.*?)(;|\\s|$).*");
    }
}
